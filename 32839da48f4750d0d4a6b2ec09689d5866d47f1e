{
  "comments": [
    {
      "key": {
        "uuid": "50ec1c3c_0573b6c7",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 12,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2016-11-30T09:41:47Z",
      "side": 1,
      "message": "What is the purpose of this field?\nImagine we want to move (large) objects from a local FS storage to an Amazon S3 storage.\nThis field then becomes a problem, it has wrong value after objects are moved from one to another backend.",
      "revId": "32839da48f4750d0d4a6b2ec09689d5866d47f1e",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "50ec1c3c_e577b2af",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 13,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2016-11-30T09:41:47Z",
      "side": 1,
      "message": "Similar issue here....\n\nThe association of (project \u003e LFS backend) is defined in the refs/meta/config:lfs.config file.\nI currently don\u0027t see a good reason to have this field in the index. This makes moving objects from one backend to another difficult.",
      "revId": "32839da48f4750d0d4a6b2ec09689d5866d47f1e",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "70e76057_a6a77258",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 15,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2016-11-30T09:41:47Z",
      "side": 1,
      "message": "What is the meaning of the commit field? Given the following commit history where all paths\nare actually LFS pointers:\n\n  c3 \u003c master\n  |\n  c2 (update A.mp3 \u003e oid2, create B.avi \u003e oid3)\n  |\n  c1 (create A.mp3 \u003e oid1)\n\nWhich exactly document will we have in the index when master is updated to point to c3?\nSpecifically, I am interested if (commit, oid) means that the oid is reachable from that commit\nor only that the oid was introduced in that commit.",
      "revId": "32839da48f4750d0d4a6b2ec09689d5866d47f1e",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "70e76057_86322e4d",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 17,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2016-11-30T09:41:47Z",
      "side": 1,
      "message": "If the index would only consist of these fields then moving objects between LFS backends would be easy.",
      "range": {
        "startLine": 14,
        "startChar": 0,
        "endLine": 17,
        "endChar": 6
      },
      "revId": "32839da48f4750d0d4a6b2ec09689d5866d47f1e",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "70e76057_662f2ae5",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 24,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2016-11-30T09:41:47Z",
      "side": 1,
      "message": "IMO, you don\u0027t need to differentiate between fast-forward and non-fast-forward update.\nAll that matters for processing an ref-update is the oldId and newId. You just need to compute the diff between the two trees (old and new) and search for LFS pointer files inside the diff.",
      "revId": "32839da48f4750d0d4a6b2ec09689d5866d47f1e",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    }
  ]
}