{
  "comments": [
    {
      "key": {
        "uuid": "1ddb6d72_335ddc8d",
        "filename": "/COMMIT_MSG",
        "patchSetId": 14
      },
      "lineNbr": 21,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2017-06-02T09:41:16Z",
      "side": 1,
      "message": "Is is a flat list of lock files under the {project} folder? How many locks do we expect per project? Does it make sense to think about sharding the locks into several subfolders of the {project} folder?",
      "revId": "32741cbb0d132fa5e2cfd9140367eca0db0411e3",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fb3f492b_01753f72",
        "filename": "/COMMIT_MSG",
        "patchSetId": 14
      },
      "lineNbr": 21,
      "author": {
        "id": 1025452
      },
      "writtenOn": "2017-06-02T13:55:21Z",
      "side": 1,
      "message": "have no experience here :/ but it sharding (by for instance first 2-3 letters) should be pretty easy to implement...",
      "parentUuid": "1ddb6d72_335ddc8d",
      "revId": "32741cbb0d132fa5e2cfd9140367eca0db0411e3",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9a91199e_a275f3a2",
        "filename": "/COMMIT_MSG",
        "patchSetId": 14
      },
      "lineNbr": 28,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2017-06-02T09:41:16Z",
      "side": 1,
      "message": "I have some doubts about these decisions:\n\n* loading of the LfsProjectLocks (the value of the top-level) cache loads all locks for this project. This is potentially\nslow. The first caller (and also the first caller after cache expiration) has to wait longer.\n\n* This caches either all locks of a project or nothing for that project. This means that if we have 10K locks on a project\nand only one of them is being accessed actively, then the other 10K-1 will not be evicted from memory (because they can only be evicted all as one unit)\n\n* care must be taken that no place this code stores a reference to the LfsProjectLocks obtained from the top-level Cache.\nThe stored reference becomes obsolete after the LFsProjectLocks instance is evicted and loaded again.\n\nHave you considered having one cache only where the cache key is: [project, lockId] ?",
      "revId": "32741cbb0d132fa5e2cfd9140367eca0db0411e3",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9f9e4db2_8e912818",
        "filename": "/COMMIT_MSG",
        "patchSetId": 14
      },
      "lineNbr": 28,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2017-06-02T09:55:43Z",
      "side": 1,
      "message": "if you want we can submit this change as it is now and think about improving the caching afterwards. Since the persistence of file locks doesn\u0027t need to change, we can change the cache implementation in a follow-up change without needing to migrate anything. However, my previous question (line 21) is important if we think about a large number of locks.",
      "parentUuid": "9a91199e_a275f3a2",
      "revId": "32741cbb0d132fa5e2cfd9140367eca0db0411e3",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c618f97f_2ce751e7",
        "filename": "/COMMIT_MSG",
        "patchSetId": 14
      },
      "lineNbr": 28,
      "author": {
        "id": 1025452
      },
      "writtenOn": "2017-06-02T13:55:21Z",
      "side": 1,
      "message": "\u003e Have you considered having one cache only where the cache key is: [project, lockId] ?\n\ngets problematic in the moment when client calls\n- locks/verify (which is btw the method to check if LFS locks API is available)\n- lock that returns all locks for project\nboth these methods at least in theory could use cursor and limit to lower the number of returned entries but regardless they have to operate on sth which is real which means data is loaded\n\nI am opened to other suggestions (was considering to use for instance refs from lfs_locks namespace of project but have no idea how that would/could scale to thousands of locks ;))",
      "parentUuid": "9a91199e_a275f3a2",
      "revId": "32741cbb0d132fa5e2cfd9140367eca0db0411e3",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cc62486a_8a833079",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/lfs/locks/LfsLocksHandler.java",
        "patchSetId": 14
      },
      "lineNbr": 59,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2017-06-02T09:41:16Z",
      "side": 1,
      "message": "projectLocks ?",
      "range": {
        "startLine": 59,
        "startChar": 63,
        "endLine": 59,
        "endChar": 71
      },
      "revId": "32741cbb0d132fa5e2cfd9140367eca0db0411e3",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fb0835a9_d18b93c8",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/lfs/locks/LfsLocksHandler.java",
        "patchSetId": 14
      },
      "lineNbr": 59,
      "author": {
        "id": 1025452
      },
      "writtenOn": "2017-06-02T13:55:21Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "cc62486a_8a833079",
      "range": {
        "startLine": 59,
        "startChar": 63,
        "endLine": 59,
        "endChar": 71
      },
      "revId": "32741cbb0d132fa5e2cfd9140367eca0db0411e3",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ff94d14e_960c1a26",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/lfs/locks/LfsLocksModule.java",
        "patchSetId": 14
      },
      "lineNbr": 32,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2017-06-02T09:41:16Z",
      "side": 1,
      "message": "Why does this need to be a @Provides method?\nOur standard way of binding a cache is by subclassing the CacheModule and then using its DSL:\n\n  cache(\"\u003cname\u003e\", Key.class, Value.class)\n      .loader(Loader.class);",
      "revId": "32741cbb0d132fa5e2cfd9140367eca0db0411e3",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2709deeb_a8be4349",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/lfs/locks/LfsLocksModule.java",
        "patchSetId": 14
      },
      "lineNbr": 32,
      "author": {
        "id": 1025452
      },
      "writtenOn": "2017-06-02T13:55:21Z",
      "side": 1,
      "message": "done - thanks for noticing, was somehow under impression that I will have to provide somehow loader not class ;)",
      "parentUuid": "ff94d14e_960c1a26",
      "revId": "32741cbb0d132fa5e2cfd9140367eca0db0411e3",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "645842a5_077eecbc",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/lfs/locks/LfsLocksModule.java",
        "patchSetId": 14
      },
      "lineNbr": 32,
      "author": {
        "id": 1025452
      },
      "writtenOn": "2017-06-02T14:12:42Z",
      "side": 1,
      "message": "there is one drawback though Gerrit cache DSL doesn\u0027t handle expiresAfterRead and what is more it implies default limitations like 1024 entries...\nnow I started to have some doubts ;) expiring after X time of write doesn\u0027t look reasonable to me and keeping locks forever in memory sucks too...",
      "parentUuid": "2709deeb_a8be4349",
      "revId": "32741cbb0d132fa5e2cfd9140367eca0db0411e3",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    }
  ]
}